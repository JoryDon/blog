# 山水云图

## webpack中loader和plugin的区别
loader 是加载和编译文件代码
plugin 是完成loader完成不了的任务, 比如解析css/图片文件

## 浏览器输入网址发生了什么
CDN
缓存
DNS
TCP三次握手、四次挥手
浏览器渲染过程

## 浏览器的重绘和回流的区别
重绘(repaint)：当元素样式的改变不影响页面布局时，比如元素的颜色，浏览器将对元素进行的更新，称之为重绘。

常见的重绘操作有：
1，改变元素颜色
2，改变元素背景色

回流(reflow)：也叫做重排。当元素的尺寸或者位置发生了变化，就需要重新计算渲染树，这就是回流，比如元素的宽高、位置，浏览器会重新渲染页面，称为回流，又叫重排（layout）。

回流是影响浏览器性能的关键因素。因为一个元素的回流，可能会导致了其所有子元素以及紧随其后的节点、或祖先节点元素，或部分页面或整个页面的回流

关系：回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高.

DOM 样式发生了变化，但没有影响到页面布局时，会触发重绘，而不会触发回流。
重绘由于 DOM 位置信息不需要更新，省去了布局过程，因而性能上优于回流

视图更新渲染
微任务队列执行完成后，也就是一次事件循环结束后，浏览器会执行视图渲染，当然这里会有浏览器的优化，可能会合并多次循环的结果做一次视图重绘，因此视图更新是在事件循环之后，所以并不是每一次操作 Dom 都一定会立马刷新视图。视图重绘之前会先执行 requestAnimationFrame 回调，那么对于 requestAnimationFrame 是微任务还是宏任务是有争议的，在这里看来，它应该既不属于微任务，也不属于宏任务。

## 事件循环机制
执行栈与任务队列
JS 在解析一段代码时，会将同步代码按顺序排在某个地方，即执行栈，然后依次执行里面的函数。当遇到异步任务时就交给其他线程处理，待当前执行栈所有同步代码执行完成后，会从一个队列中去取出已完成的异步任务的回调加入执行栈继续执行，遇到异步任务时又交给其他线程，…，如此循环往复。而其他异步任务完成后，将回调放入任务队列中待执行栈来取出执行。

JS 按顺序执行执行栈中的方法，每次执行一个方法时，会为这个方法生成独有的执行环境（上下文 context)，待这个方法执行完成后，销毁当前的执行环境，并从栈中弹出此方法（即消费完成），然后继续下一个方法。
可见，在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。

## 宏任务和微任务的区别
任务队列不只一个，根据任务的种类不同，可以分为微任务（micro task）队列和宏任务（macro task）队列。

事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，**因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。**另外我们常见的点击和键盘等事件也属于宏任务。

下面我们看一下常见宏任务和常见微任务。

常见宏任务：

setTimeout()
setInterval()
setImmediate()
常见微任务：

promise.then()、promise.catch()
new MutaionObserver()
process.nextTick()

console.log('同步代码1');
setTimeout(() => {
    console.log('setTimeout')
}, 0)
new Promise((resolve) => {
  console.log('同步代码2')
  resolve()
}).then(() => {
    console.log('promise.then')
})
console.log('同步代码3');
// 最终输出"同步代码1"、"同步代码2"、"同步代码3"、"promise.then"、"setTimeout"

上面的代码将按如下顺序输出为：“同步代码 1”、“同步代码 2”、“同步代码 3”、“promise.then”、“setTimeout”，具体分析如下。

（1）setTimeout 回调和 promise.then 都是异步执行的，将在所有同步代码之后执行；

顺便提一下，在浏览器中 setTimeout 的延时设置为 0 的话，会默认为 4ms，NodeJS 为 1ms。具体值可能不固定，但不是为
0。

（2）虽然 promise.then 写在后面，但是执行顺序却比 setTimeout 优先，因为它是微任务；

（3）new Promise 是同步执行的，promise.then 里面的回调才是异步的。

也有人这样去理解：微任务是在当前事件循环的尾部去执行；宏任务是在下一次事件循环的开始去执行。我们来看看微任务和宏任务的本质区别是什么。

我们已经知道，JS 遇到异步任务时会将此任务交给其他线程去处理，自己的主线程继续往后执行同步任务。比如 setTimeout 的计时会由浏览器的定时器线程来处理，待计时结束，就将定时器回调任务放入任务队列等待主线程来取出执行。前面我们提到，因为 JS 是单线程执行的，所以要执行异步任务，就需要浏览器其他线程来辅助，即多线程是 JS 异步任务的一个明显特征。

我们再来分析下 promise.then（微任务）的处理。当执行到 promise.then 时，V8 引擎不会将异步任务交给浏览器其他线程，而是将回调存在自己的一个队列中，待当前执行栈执行完成后，立马去执行 promise.then 存放的队列，promise.then 微任务没有多线程参与，甚至从某些角度说，微任务都不能完全算是异步，它只是将书写时的代码修改了执行顺序而已。

setTimeout 有“定时等待”这个任务，需要定时器线程执行；ajax 请求有“发送请求”这个任务，需要 HTTP 线程执行，而 promise.then 它没有任何异步任务需要其他线程执行，它只有回调，即使有，也只是内部嵌套的另一个宏任务。

简单小结一下微任务和宏任务的本质区别。


### 宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。
### 微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。

## 宏任务和微任务的执行顺序
事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，**因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。**
也有人这么理解: 微任务是在当前事件循环的尾部去执行；宏任务是在下一次事件循环的开始去执行

### 定时器误差
事件循环中，总是先执行同步代码后，才会去任务队列中取出异步回调来执行。当执行 setTimeout 时，浏览器启动新的线程去计时，计时结束后触发定时器事件将回调存入宏任务队列，等待 JS 主线程来取出执行。如果这时主线程还在执行同步任务的过程中，那么此时的宏任务就只有先挂起，这就造成了计时器不准确的问题。同步代码耗时越长，计时器的误差就越大。不仅同步代码，由于微任务会优先执行，所以微任务也会影响计时，假设同步代码中有一个死循环或者微任务中递归不断在启动其他微任务，那么宏任务里面的代码可能永远得不到执行。所以主线程代码的执行效率提升是一件很重要的事情。

一个很简单的场景就是我们界面上有一个时钟精确到秒，每秒更新一次时间。你会发现有时候秒数会直接跳过 2 秒间隔，就是这个原因。


## 同步代码和异步代码的执行顺序, 加载外来资源的执行顺序


## 加载异步任务,js引擎是阻塞呢? 还是继续执行

## js的垃圾回收机制
js 垃圾回收机制（GC）
1、GC–garbage collection ,js具有“自动”垃圾回收机制
即执行环境会负责管理代码执行过程中使用的内存
2、GC会定期（周期性的）找出那些不再继续使用的变量，然后释放其内存
3、不再使用的变量即生命周期结束的变量会被释放，只能是局部变量
全局变量的生命周期，直到浏览器卸载页面才会结束
4、闭包由于内部函数原因，外部函数不能算结束，无法释放内存
5、js的垃圾回收机制----采用的方式
(1)标记清除法
当变量进入执行环境时,就将这个变量标记为“进入环境”,当变量离开环境时会被标记“离开环境”,离开环境的变量内存被释放

        function f1(){
            //被标记已进入执行环境
            var a=1
            var b=2
        }
        f1()  //执行完毕，a，b被标记离开执行环境，内存释放

(2)引用计数法
跟踪记录每个值被引用的次数，当某个值的引用次数变为0时，说明没有方法在访问该值了，则可将其占用的内存收回
function f1(){
            //跟踪a的引用计数
            var a={}   //a的引用次数 0
            var b=a    //a的引用次数 1
            var c=a     //a的引用次数 2
            var b={}    //a的引用次数 1
            var c=[]    //a的引用次数 0
        }

(3)手工 --直接置空，GC下次再运行时会删除这些值
a=null


## 闭包,一句话概括

闭包就是内部函数可以访问外部函数的变量.
闭包是指在一个函数内部定义的函数可以访问该函数作用域中的变量和参数，即使外部函数已经执行完毕，这些变量和参数依然可以被内部函数使用。

### 优点:

1. 可以实现数据封装和保护，避免全局命名空间污染，
2. 并且可以实现函数式编程的一些高级特性，如柯里化和惰性求值等。

### 缺点:
是可能导致内存泄漏和性能问题，因为闭包会持有对外部函数作用域的引用，如果不及时释放可能会导致内存泄漏；同时，对于频繁调用的闭包函数，由于每次调用都需要重新创建闭包，可能会影响性能。因此，在使用闭包时需要注意内存管理和性能优化。

## 虚拟DOM的优缺点
虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象 状态变更时，记录新树和旧树的差异
最后把差异更新到真正的dom中.
虚拟DOM的作用：使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，往往是DOM标签
和js逻辑同时写在js文件里，数据交互时不时还要写很多的input隐藏域，如果没有好的代码规范的话会显得代码非常冗
余混乱，耦合性高并且难以维护。
另外一方面在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的，常常会出现页面卡死的情况；所以尽量减少对
DOM的操作成为了优化前端性能的必要手段，vdom就是将DOM的对比放在了js层，通过对比不同之处来选择新渲染
DOM节点，从而提高渲染效率。

### 优点：
保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限
无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率
跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等
### 缺点：
无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优化


## 最近关注那些技术

## 未来规划